from burp import IBurpExtender
from burp import IHttpListener
import urlparse  # For parsing query parameters in Jython 2.7

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("CustomRequestBodyModifier")
        callbacks.registerHttpListener(self)
        print("Extension Loaded: Custom Request Body Modifier")

        # Path-based rules: map endpoint to {target_string: replacement_body}
        self.path_rules = {
            "/api/endpoint1": {
                "error_trigger": '{"error": "Modified due to error_trigger"}',
                "unauthorized": '{"error": "Modified due to unauthorized"}',
                "bad_request": '{"error": "Modified due to bad_request"}'
            },
            "/api/endpoint2": {
                "invalid": '{"error": "Modified due to invalid"}',
                "forbidden": '{"error": "Modified due to forbidden"}',
                "not_found": '{"error": "Modified due to not_found"}'
            }
        }

        # Parameter-based rules: map param_key_value to {target_string: replacement_body}
        self.param_rules = {
            "action=submit": {
                "submit_error": '{"error": "Modified due to submit_error"}',
                "no_access": '{"error": "Modified due to no_access"}'
            },
            "id=123": {
                "invalid_id": '{"error": "Modified due to invalid_id"}',
                "id_not_found": '{"error": "Modified due to id_not_found"}'
            }
        }

    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        if messageIsRequest:  # Process requests (changed from responses)
            request = messageInfo.getRequest()
            request_info = self._helpers.analyzeRequest(messageInfo)
            url = request_info.getUrl()
            path = url.getPath()
            request_body = self._helpers.bytesToString(request[request_info.getBodyOffset():])
            print("Processing request to %s with body: %s..." % (path, request_body[:100]))

            # Extract query parameters
            query = url.getQuery()
            query_params = {}
            if query:
                query_params = dict(urlparse.parse_qsl(query))

            # Check parameter-based rules
            for param_key_value, string_to_body in self.param_rules.items():
                param_key, param_value = param_key_value.split("=", 1)
                if param_key in query_params and query_params[param_key] == param_value:
                    for target_string, new_body in string_to_body.items():
                        if target_string in request_body:
                            # Get request headers
                            headers = request_info.getHeaders()
                            new_headers = []
                            content_length_updated = False

                            # Update Content-Length header
                            for header in headers:
                                if header.lower().startswith("content-length:"):
                                    content_length_updated = True
                                    new_headers.append("Content-Length: %s" % len(new_body))
                                else:
                                    new_headers.append(header)
                            if not content_length_updated:
                                new_headers.append("Content-Length: %s" % len(new_body))

                            # Build new request with modified body
                            modified_request = self._helpers.buildHttpMessage(new_headers, new_body)
                            messageInfo.setRequest(modified_request)
                            print("Modified request body for param %s: %s -> %s" % (param_key_value, target_string, new_body[:100]))
                            return  # Exit after first match

            # Check path-based rules
            for endpoint, string_to_body in self.path_rules.items():
                if path.endswith(endpoint):
                    for target_string, new_body in string_to_body.items():
                        if target_string in request_body:
                            # Get request headers
                            headers = request_info.getHeaders()
                            new_headers = []
                            content_length_updated = False

                            # Update Content-Length header
                            for header in headers:
                                if header.lower().startswith("content-length:"):
                                    content_length_updated = True
                                    new_headers.append("Content-Length: %s" % len(new_body))
                                else:
                                    new_headers.append(header)
                            if not content_length_updated:
                                new_headers.append("Content-Length: %s" % len(new_body))

                            # Build new request with modified body
                            modified_request = self._helpers.buildHttpMessage(new_headers, new_body)
                            messageInfo.setRequest(modified_request)
                            print("Modified request body for %s: %s -> %s" % (endpoint, target_string, new_body[:100]))
                            return  # Exit after first match
