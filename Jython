from burp import IBurpExtender
from burp import IHttpListener

class BurpExtender(IBurpExtender, IHttpListener):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("CustomRequestBodyModifier")
        callbacks.registerHttpListener(self)
        print("Extension Loaded: Custom Request Body Modifier")

        # Path-based rules: map endpoint to {target_string: replacement_body}
        self.path_rules = {
            "/api/endpoint1": {
                "error_trigger": '{"error": "Modified due to error_trigger"}',
                "unauthorized": '{"error": "Modified due to unauthorized"}',
                "bad_request": '{"error": "Modified due to bad_request"}'
            },
            "/api/endpoint2": {
                "invalid": '{"error": "Modified due to invalid"}',
                "forbidden": '{"error": "Modified due to forbidden"}',
                "not_found": '{"error": "Modified due to not_found"}'
            }
        }

        # URL string-based rules: map URL substring to {target_string: replacement_body}
        self.url_rules = {
            "submit": {
                "submit_error": '{"error": "Modified due to submit_error"}',
                "no_access": '{"error": "Modified due to no_access"}'
            },
            "user123": {
                "invalid_id": '{"error": "Modified due to invalid_id"}',
                "id_not_found": '{"error": "Modified due to id_not_found"}'
            }
        }

    def processHttpMessage(self, toolFlag, messageIsRequest, messageInfo):
        if messageIsRequest:  # Process requests
            request = messageInfo.getRequest()
            request_info = self._helpers.analyzeRequest(messageInfo)
            url = request_info.getUrl()
            path = url.getPath()
            # Get full URL (path + query) as string
            full_url = url.toString()
            request_body = self._helpers.bytesToString(request[request_info.getBodyOffset():])
            print("Processing request to %s with body: %s..." % (path, request_body[:100]))

            # Check URL string-based rules
            for url_string, string_to_body in self.url_rules.items():
                if url_string in full_url:  # Case-sensitive match
                    for target_string, new_body in string_to_body.items():
                        if target_string in request_body:
                            # Get request headers
                            headers reconocido = request_info.getHeaders()
                            new_headers = []
                            content_length_updated = False

                            # Update Content-Length header
                            for header in headers:
                                if header.lower().startswith("content-length:"):
                                    content_length_updated = True
                                    new_headers.append("Content-Length: %s" % len(new_body))
                                else:
                                    new_headers.append(header)
                            if not content_length_updated:
                                new_headers.append("Content-Length: %s" % len(new_body))

                            # Build new request with modified body
                            modified_request = self._helpers.buildHttpMessage(new_headers, new_body)
                            messageInfo.setRequest(modified_request)
                            print("Modified request body for URL string %s: %s -> %s" % (url_string, target_string, new_body[:100]))
                            return  # Exit after first match

            # Check path-based rules (fallback)
            for endpoint, string_to_body in self.path_rules.items():
                if path.endswith(endpoint):
                    for target_string, new_body in string_to_body.items():
                        if target_string in request_body:
                            # Get request headers
                            headers = request_info.getHeaders()
                            new_headers = []
                            content_length_updated = False

                            # Update Content-Length header
                            for header in headers:
                                if header.lower().startswith("content-length:"):
                                    content_length_updated = True
                                    new_headers.append("Content-Length: %s" % len(new_body))
                                else:
                                    new_headers.append(header)
                            if not content_length_updated:
                                new_headers.append("Content-Length: %s" % len(new_body))

                            # Build new request with modified body
                            modified_request = self._helpers.buildHttpMessage(new_headers, new_body)
                            messageInfo.setRequest(modified_request)
                            print("Modified request body for %s: %s -> %s" % (endpoint, target_string, new_body[:100]))
                            return  # Exit after first match
